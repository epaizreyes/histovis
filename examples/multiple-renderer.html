<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>HistoVis - Multiple Image Visualization</title>
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <link rel="shortcut icon" href="https://histovis.s3.eu-west-3.amazonaws.com/icons/histovis.ico">
        <style>
            html { height: 100%; }
            body { margin: 0; overflow: hidden; height: 100%; }
            #viewerDiv { margin: auto; height: 100%; width: 100%; padding: 0; }
            canvas { display: block }
        </style>
    </head>
    <body>
        <script src="../dist/itowns.js"></script>
        <script>
            // Itowns library
            var itowns = histovis.itowns;
        </script>

        <script src="../dist/three.js"></script>
        <script>
            // Three library
            var THREE = histovis.THREE;
            // Data GUI
            var GUI = histovis.GUI;
        </script>

        <script src="../dist/three-additional.js"></script>
        <script>
            // Three additional
            var PLYLoader = histovis.PLYLoader;
            var LineMaterial = histovis.LineMaterial;
            var LineSegmentsGeometry = histovis.LineSegmentsGeometry;
            var LineSegments2 = histovis.LineSegments2;
        </script>

        <script src="../dist/photogrammetric-camera.js"></script>
        <script>
            // Files Management
            var FetchSource = histovis.photogrammetricCamera.FetchSource;
            var FilesSource = histovis.photogrammetricCamera.FilesSource;
            // Parsers
            var MatisOrientationParser = histovis.photogrammetricCamera.MatisOrientationParser;
            var MicmacOrientationParser = histovis.photogrammetricCamera.MicmacOrientationParser;
            var GoogleOrientationParser = histovis.GoogleOrientationParser;
            // Materials
            var OrientedImageMaterial = histovis.photogrammetricCamera.OrientedImageMaterial;
            var MultipleOrientedImageMaterial = histovis.photogrammetricCamera.MultipleOrientedImageMaterial;
            var imageVS = histovis.photogrammetricCamera.imageVS;
            var imageFS = histovis.photogrammetricCamera.imageFS;
            var multipleVS = histovis.photogrammetricCamera.multipleVS;
            var multipleFS = histovis.photogrammetricCamera.multipleFS;
            // Photogrammetric camera
            var PhotogrammetricCamera = histovis.photogrammetricCamera.PhotogrammetricCamera;
        </script>

        <script src="../dist/cluster.js"></script>
        <script>
            // Image representation
            var HistoricalImage = histovis.HistoricalImage;
            // Clustering
            var HierarchicalCluster = histovis.HierarchicalCluster;
            // Photo gallery
            var Border = histovis.Border;

            var lineVS = histovis.lineVS;
            var lineFS = histovis.lineFS;
        </script>

        <script src="js/helper/photogrammetricHelper.js"></script>
        <script src="js/helper/photogrammetricHelperGlobe.js"></script>

        <script src="js/helper/clusterHelper.js"></script>

        <!-- Load d3.js and the timeline -->
        <script src="https://d3js.org/d3.v4.js"></script>
        <script src="js/web/timeline.js"></script>

        <script>
            /* ------------------------- Main ------------------------ */
            init();
            var gui = initGUI();
            animate();

            /* ----------------------- Functions --------------------- */
            function init() {
                // HTML container for the rendering scene
                var container = document.createElement('div');
                container.setAttribute('id', 'viewerDiv');
                document.body.appendChild(container);

                // Sizes
                width = window.innerWidth;
                height = window.innerHeight;

                // View Camera
                viewCamera.zoom = 0.5;
                viewCamera.up.set(0, 0, 1);

                // Globe
                initGlobe(container, viewCamera);
                globeRendering = true;
            
                // Controls
                controls = new itowns.FirstPersonControls(view);

                // Scene
                scene = view.scene;
                //scene.background = new THREE.Color(0xf0f0f0);

                // Cameras 
                cameras = new THREE.Group();
                cameras.visible = true;
                scene.add(viewCamera);
                scene.add(cameras);
                
                // Materials
                basicMaterial = initBasicMaterial();
                wireMaterial = initWireMaterial();
                spriteMaterial = initSpriteMaterial(spriteTexture);
                [multipleTextureMaterialUniforms, multipleTextureMaterial] = initMultipleTextureMaterial(
                    multipleVS, multipleFS, uvTexture, view.mainLoop.gfxEngine.renderer);
                markerMaterialUniforms = initMarkerMaterialUniforms(lineVS, lineFS);

                multipleTextureMaterial.border.linewidth = 3;

                // Environment
                environment = new THREE.Group();
                backgroundSphere = initBackgroundSphere(multipleTextureMaterial);
                worldPlane = initWorldPlane(multipleTextureMaterial);

                environment.add(backgroundSphere);
                environment.add(worldPlane);
                environment.visible = false;

                initBuildings(multipleTextureMaterial);

                scene.add(environment);

                // Renderer
                renderer = view.mainLoop.gfxEngine.renderer;

                // 2D canvas
                var canvas = renderer.getContext().canvas;

                // Border
                border = new Border(canvas.width, canvas.height);

                // Show the materials
                showMaterials(true);
                
                // Raycaster and mouse
                raycaster = new THREE.Raycaster();
                raycaster.params.Line.threshold = 3;
                raycaster.camera = viewCamera;

                mouse = new THREE.Vector2();

                // Viewpoint marker
                marker = new THREE.Group();

                // Available collections
                collections = {
                    Database1: {
                        selection: false,
                        color: new THREE.Color(0xffffff).setHex(Math.random() * 0xffffff).getHex(),
                        cameras: [],
                        load: function() {
                            var name = 'Database1';
                            markerMaterialUniforms.color = collections[name].color;
                            params.collection = 'collections/ign_nanterre/';
                            loadJSONGlobe(multipleTextureMaterial, server + params.collection, 'index-data1.json', name);
                        },
                        unload: function() {
                            var name = 'Database1';
                            params.collection = 'collections/ign_nanterre/';
                            unloadJSONGlobe(name);
                        }
                    },
                    Database2: {
                        selection: false,
                        color: new THREE.Color(0xffffff).setHex(Math.random() * 0xffffff).getHex(),
                        cameras: [],
                        load: function() {
                            var name = 'Database2';
                            markerMaterialUniforms.color = collections[name].color;
                            params.collection = 'collections/ign_nanterre/';
                            loadJSONGlobe(multipleTextureMaterial, server + params.collection, 'index-data2.json', name);
                        },
                        unload: function() {
                            var name = 'Database2';
                            unloadJSONGlobe(name);
                        }
                    },
                    Database3: {
                        selection: false,
                        color: new THREE.Color(0xffffff).setHex(Math.random() * 0xffffff).getHex(),
                        cameras: [],
                        load: function() {
                            var name = 'Database3';
                            markerMaterialUniforms.color = collections[name].color;
                            params.collection = 'collections/ign_nanterre/';
                            loadJSONGlobe(multipleTextureMaterial, server + params.collection, 'index-data3.json', name);
                        },
                        unload: function() {
                            var name = 'Database3';
                            unloadJSONGlobe(name);
                        }
                    }
                };

                // Event listeners
                document.addEventListener('keydown', onDocumentKeyDown, false);
                window.addEventListener('resize', function() {
                    var canvas = renderer.getContext().canvas;
                    border = new Border(canvas.width, canvas.height);
                }, false);

                document.addEventListener('mousemove', onDocumentMouseMove, false);

                document.addEventListener('click', event => {
                    params.mouse.timer = setTimeout(function() {
                    if (!params.mouse.prevent) {
                        onDocumentMouseClick(event);
                    }
                    params.mouse.prevent = false;
                    }, params.mouse.delay);
                });

                document.addEventListener('dblclick', event => {
                    clearTimeout(params.mouse.timer);
                    params.mouse.prevent = true;
                    onDocumentMouseDblClick(event);
                });

                /* Rendering ----------------------------------------- */
                view.render = function render(){
                    renderer.setRenderTarget(null);
                    renderer.clear();

                    if(globeRendering) renderer.render(view.scene, viewCamera);
                    else renderer.render(scene, viewCamera);
                }

                /* Clean --------------------------------------------- */
                function clean() {
                    basicClean();

                    cluster = new HierarchicalCluster();
                    params.clustering = {active: false, images: 0, clusters: 0};
                    params.timeline = {intervals: 12};
                }
            }

            function initGUI() {
                var gui = new GUI();

                var collectionsGUI = gui.addFolder('Collections');
                for(const key in collections) {
                    collectionsGUI.add(collections[key], 'selection').name(key).onChange(function (value) {
                        if(value == true) collections[key].load();
                        else collections[key].unload();
                    });
                    collectionsGUI.addColor(collections[key], 'color').onChange(function (value) {
                        collections[key].cameras.forEach(name => markerMaterials[name].color = new THREE.Color(value));
                    });
                }
                collectionsGUI.closed = false;

                // View Camera
                function updateViewCameraFromGUI() {
                    viewCamera.updateProjectionMatrix();
                    view.notifyChange(view.camera.camera3D);
                };

                var viewGUI = gui.addFolder('View Camera'); 
                viewGUI.zoom = viewGUI.add(viewCamera, 'zoom', 0.1, 2.0).onChange(updateViewCameraFromGUI);

                // Texture Camera
                var textureGUI = gui.addFolder('Historical Camera');
                textureGUI.opacity = textureGUI.add(view.getLayers()[2], 'opacity', 0, 0.99);

                // Viewpoint Markers
                function updateViewpointMarkersFromGUI(value) {
                    cameras.visible = value;
                    multipleTextureMaterial.border.visible = value;
                }

                function updateMarkerTargetFromGUI(value) {
                    params.markers.target = value;
                    cameras.children.forEach(cam => cam.children[0].children[1].visible = params.markers.target);
                }

                function updateMarkerNearFromGUI(value) {
                    params.markers.near = value;
                    cameras.children.forEach(cam => cam.children[0].children[2].visible = params.markers.near);
                }

                function updateMarkerFarFromGUI(value) {
                    params.markers.far = value;
                }

                var markerGUI = gui.addFolder('Viewpoint Markers');
                markerGUI.show = markerGUI.add(cameras, 'visible').onChange(updateViewpointMarkersFromGUI).name('show');
                markerGUI.near = markerGUI.add(params.markers, 'target').onChange(updateMarkerTargetFromGUI);
                markerGUI.near = markerGUI.add(params.markers, 'near').onChange(updateMarkerNearFromGUI);
                markerGUI.near = markerGUI.add(params.markers, 'far').onChange(updateMarkerFarFromGUI);

                // Clustering options
                function updateClusterFromGUI(value) {
                    params.clustering.clusters = Math.floor(value);
                }

                function updateClusterImageFromGUI(value) {
                    params.clustering.images = Math.floor(value);
                }

                var clusteringGUI = gui.addFolder('Clustering');
                clusteringGUI.images = clusteringGUI.add(params.clustering, 'images', 0, 0).onChange(updateClusterImageFromGUI);
                clusteringGUI.clusters = clusteringGUI.add(params.clustering, 'clusters', 0, 0).onChange(updateClusterFromGUI);

                // Background 
                function updateElevationFromGUI(value) {
                    params.environment.elevation = value;
                    if(globeRendering) updateEnvironmentGlobe();
                    else updateEnvironment();
                }
                var backgroundGUI = gui.addFolder('Background');
                backgroundGUI.wireframe = backgroundGUI.add(multipleTextureMaterial, 'wireframe');
                backgroundGUI.sphere = backgroundGUI.add(backgroundSphere, 'visible').name('sphere visible');
                backgroundGUI.plane = backgroundGUI.add(worldPlane, 'visible').name('plane visible');
                backgroundGUI.elevation = backgroundGUI.add(params.environment, 'elevation', -100, 100)
                    .name('plane elevation').onChange(updateElevationFromGUI);

                // Debug
                var debugGUI = gui.addFolder('Debug');
                debugGUI.borderSharpness = debugGUI.add(multipleTextureMaterial.debug, 'borderSharpness', 2, 1000).name("border sharpness");
                debugGUI.diffuseColorGrey = debugGUI.add(multipleTextureMaterial.debug, 'diffuseColorGrey');

                // Update controls functions
                gui.updateGUI = function updateGUI() {
                    viewGUI.zoom.setValue(viewCamera.zoom);
                    backgroundGUI.sphere.setValue(environment.children[0].visible);
                    backgroundGUI.plane.setValue(environment.children[1].visible);
                    backgroundGUI.elevation.setValue(params.environment.elevation);
                    
                    var name = textureCamera.name;
                    if (name.length > 0) {
                        if(name.length > 20) name = name.substr(0,8)+'[..]'+name.substr(-8,8);
                        textureGUI.name = 'Hist: ' + name;
                    }

                    clusteringGUI.images.max(Object.values(names).length);
                    clusteringGUI.images.setValue(Math.floor(params.clustering.images));

                    clusteringGUI.clusters.max(params.clustering.images);
                    clusteringGUI.clusters.setValue(Math.floor(params.clustering.clusters));
                }
                return gui;
            }

            function animate(timestamp) {
                if(textureCamera.name == "" && cameras.children.length > 0) setCamera(getCamera(cameras.children[0]));
                interpolateCameraGlobe(timestamp);
                updateCluster(viewCamera);
                gui.updateGUI();
                updateTimeline();
                if(!globeRendering) view.notifyChange(true);
                requestAnimationFrame(animate);
            }
        </script>
    </body>
</html>