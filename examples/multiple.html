<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>HistoVis - Multiple Image Visualization</title>
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <link rel="stylesheet" href="style/w3.css">
        <link rel="stylesheet" href="style/style.css">
        <link rel="stylesheet" href="style/menu.css">
        <link rel="stylesheet" href="style/timeline.css">
        <link rel="stylesheet" href="style/charts.min.css">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
        <link rel="shortcut icon" href="https://histovis.s3.eu-west-3.amazonaws.com/icons/histovis.ico">
        <style>
            svg .selection, svg .overlay {
                fill: #f27793;
            }

            svg text {
              font-family: 'Montserrat';
              font-weight: bold;
              font-size: 90%;
            }

            svg .overlay {
                opacity: 0.2;
                pointer-events: none;
            }
            
            svg .selection {
                fill-opacity: 0.8;
                stroke: none;
            }
            
            svg .domain {
              stroke: none;
            }
            
            svg .tick text {
             font-weight: normal;
            }
        </style>
    </head>
    <body class="w3-light-gray">
        <!-- Load d3.js -->
        <script src="https://d3js.org/d3.v4.js"></script>

        <!-- !Page Content -->
        <div id="myContent" class="w3-display-container w3-light-gray w3-card">
            <!-- !Canvas -->
            <iframe id="myRenderer" class = "w3-card w3-light-gray w3-margin-bottom" src="multiple-renderer.html">
            </iframe>

            <div id="myCluster"></div>
        </div>

        <div id="myTimeline" class = "w3-display-container"> 
        </div>

        <!--
        <div id="myTimeline" class = "w3-display-container"> 
            <div class="middle">
                <div id="mySliderTimeline" class="multi-range-slider">
                    <input type="range" id="input-left">
                    <input type="range" id="input-right">
            
                    <div class="slider">
                        <div class="track"></div>
                        <div class="range"></div>
                        <div class="thumb left"></div>
                        <div class="thumb right"></div>

                        <div id="labelTimeline"></div>
                    </div>
                </div>

                
                <table class="charts-css column" style = "position: absolute; width: 100%; height: 60%;">
                    <tbody id="imagesTimeline">
                        <tr>
                        <td style="--start:0.1; --size:0.5;"></td>
                        </tr>
                        <tr>
                        <td style="--start:0.5; --size:0.8;"></td>
                        </tr>
                        <tr>
                        <td style="--start:0.8; --size:0.4;"></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            -->
        </div>

        <script>
            // Create the data
            const mydata = [
                {date: new Date(1980, 0, 1), value: 81}, {date: new Date(1981, 6, 1), value: 145}, 
                {date: new Date(1982, 2, 1), value: 120}, {date: new Date(1983, 7, 1), value: 122},
                {date: new Date(1984, 3, 1), value: 6}, {date: new Date(1985, 8, 1), value: 194},
                {date: new Date(1986, 4, 1), value: 24}, {date: new Date(1987, 9, 1), value: 95},
                {date: new Date(1988, 5, 1), value: 133},  {date: new Date(1989, 1, 1), value: 70}
            ];

            var dynamicDateFormat = timeFormat([
                [d3.timeFormat("%Y"), function() { return true; }],// <-- how to display when Jan 1 YYYY
                [d3.timeFormat("%b %Y"), function(d) { return d.getMonth(); }],
                [function(){return "";}, function(d) { return d.getDate() != 1; }]
            ]);

            // Set the dimensions and margins of the graph
            var container = document.getElementById("myTimeline");
            const size = {w: container.clientWidth, h: container.clientHeight};

            var margin = {top: 0, right: 35, bottom: 25, left: 35},
                width = size.w - margin.left - margin.right,
                height = size.h - margin.top - margin.bottom;

            // Append the svg object to the body of the page
            const svg = d3.select("#myTimeline")
                .append("svg")
                .attr("preserveAspectRatio", "xMinYMin meet")
                .attr("viewBox", `0 0 ${size.w} ${size.h}`)
                .classed("svg-content-responsive", true)
                .call(zoom);

            // Translate this svg element to leave some margin.
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left}, ${margin.top})`);

            // Scale and axis
            var xScale = d3.scaleTime()
                .domain(d3.extent(mydata, d => d.date))    // This is the min and the max of the data
                .range([0, width]);                 // This is the corresponding value I want in Pixel

            var yScale = d3.scaleLinear()
                .domain(d3.extent(mydata, d => d.value))
                .range([height, 0]);

            var xAxis = d3.axisBottom()
                .scale(xScale)
                .tickFormat(dynamicDateFormat);

            var selection = [xScale(-5), xScale(width+10)];
            var zoomScale = xScale;

            g.append('g')
                .attr("class", "x-axis")
                .attr('transform', `translate(0, ${height + 10})`)
                .call(xAxis);

            // Bars
            var colors = {handle: "#f27793", bar: "#009688"};

            g.append('g')
                .attr("class", "chart")
                .selectAll('rect')
                .data(mydata)
                .enter()
                .append('rect')
                .attr('class', 'bar')
                .attr('x', d => xScale(d.date))
                .attr('y', d => height - yScale(d.value))
                .attr("width", d => xScale(d3.timeMonth.offset(d.date, 1)) - xScale(d.date) - 2)
                .attr('height', d => yScale(d.value))
                .attr('fill', colors.bar)
                .attr('opacity', 1);

            // Append brush
            var brush = d3.brushX()
                .handleSize(8)
                .extent([[0, height], [width, height + 10]])
                .on('start brush end', brushing);

            const gBrush = g.append('g')
                .call(brush)
                .call(brush.move, [-5, width + 10]);

            // Custom handlers
            const gHandles = gBrush.selectAll('g.handles')
                .data(['handle--o', 'handle--e'])
                .enter()
                .append('g')
                .attr('class', d => `handles ${d}`)
                .attr('fill', colors.handle)
                .attr('transform', d => {
                const x = d == 'handle--o' ? -5 : width+10;
                return `translate(${x}, 0)`;
                });

            // Label
            var yearFormat = d3.timeFormat("%Y");
            gHandles.selectAll('text')
                .data(d => [d])
                .enter()
                .append('text')
                .attr('text-anchor', 'middle')
                .attr('dy', 10)
                .attr('dx', 0)
                .text(d =>  d == 'handle--o' ? yearFormat(d3.min(xScale.domain())) : yearFormat(d3.max(xScale.domain())));

            // Triangle
            var triangle = d3.symbol()
                .size(50)
                .type(d3.symbolTriangle);

            gHandles.selectAll('.triangle')
                .data(d => [d])
                .enter()
                .append('path')
                .attr('class', d => `triangle ${d}`)
                .attr('d', triangle)
                .attr('transform', d => {
                    const x = d == 'handle--o' ? -6 : 6,
                        rot = d == 'handle--o' ? -90 : 90;
                    return `translate(${x}, ${size.h / 2}) rotate(${rot})`;
                });

            // Visible Line
            gHandles.selectAll('.line')
                .data(d => [d])
                .enter()
                .append('line')
                .attr('class', d => `line ${d}`)
                .attr('x1', 0)
                .attr('y1', 15)
                .attr('x2', 0)
                .attr('y2', size.h - 15)
                .attr('stroke', colors.handle);

            // Functions
            function timeFormat(formats) {
                return function(date) {
                    var i = formats.length - 1, f = formats[i];
                    while (!f[1](date)) f = formats[--i];
                    return f[0](date);
                };
            }
            
            function zoom(svg) {
                const extent = [[margin.left, margin.top], [width - margin.right, height - margin.top]];

                svg.call(d3.zoom()
                    .scaleExtent([0.25, 8])
                    .translateExtent(extent)
                    .extent(extent)
                    .on("zoom", zoomed));

                function zoomed() {
                    if (d3.event.sourceEvent && d3.event.sourceEvent.type === "brush") return; // ignore zoom-by-brush
                    var t = d3.event.transform;
                    zoomScale = t.rescaleX(xScale);
                    svg.selectAll(".x-axis").call(xAxis.scale(zoomScale));
                    svg.selectAll(".bar").attr("x", d => zoomScale(d.date)).attr("width", d => zoomScale(d3.timeMonth.offset(d.date, 1)) - zoomScale(d.date) - 2);
                    // Need to reset brush
                    gBrush.call(brush.move, [zoomScale(selection[0]), zoomScale(selection[1])]);
                    // Move handlers
                    d3.selectAll('g.handles')
                        .attr('transform', d => {
                        const x = d == 'handle--o' ? zoomScale(selection[0]) : zoomScale(selection[1]);
                        return `translate(${x}, 0)`;
                        });
                }
            }

            function brushing() {
                if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return; // ignore brush-by-zoom
                const s0 = d3.event.selection,
                d0 = [zoomScale.invert(s0[0]), zoomScale.invert(s0[1])],
                d1 = mydata.slice(d3.bisector(d => d.date).left(mydata, d0[0]), d3.bisector(d => d.date).right(mydata, d0[1]));

                // Update bars
                d3.selectAll('.bar')
                    .attr('opacity', d => d1.includes(d) ? 1 : 0.2);

                // Move handlers
                d3.selectAll('g.handles')
                    .attr('transform', d => {
                    const x = d == 'handle--o' ? zoomScale(d0[0]) : zoomScale(d0[1]);
                    return `translate(${x}, 0)`;
                    });

                // update labels
                d3.selectAll('g.handles').selectAll('text')
                    .attr('dx', d0.length > 1 ? 0 : 6)
                    .text((d, i) => {
                        let year;
                        if (d0.length > 1) {
                            year = d == 'handle--o' ? yearFormat(d3.min(d0)) : yearFormat(d3.max(d0));
                        } else {
                            year = d == 'handle--o' ? yearFormat(d3.min(d0)) : '';
                        } 
                        return year;
                    });

                selection = d0;
            }
        </script>

        <!--
        <script>
            // Create the data
            const mydata = [
                {year: new Date(1980, 1, 1), value: 81}, {year: new Date(1981, 6, 1), value: 145}, 
                {year: new Date(1982, 2, 1), value: 120}, {year: new Date(1983, 7, 1), value: 122},
                {year: new Date(1984, 3, 1), value: 6}, {year: new Date(1985, 8, 1), value: 194},
                {year: new Date(1986, 4, 1), value: 24}, {year: new Date(1987, 9, 1), value: 95},
                {year: new Date(1988, 5, 1), value: 133},  {year: new Date(1989, 10, 1), value: 70}
            ];

            var parseTime = d3.timeParse("%Y-%m-%d");

            // Set the dimensions and margins of the graph
            var container = document.getElementById("myTimeline");
            const size = {w: container.clientWidth, h: container.clientHeight};

            var margin = {top: 0, right: 10, bottom: 25, left: 10},
                width = 0.9*size.w - margin.left - margin.right,
                height = size.h - margin.top - margin.bottom;

            // Append the svg object to the body of the page
            const svg = d3.select("#scatter_area")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .call(zoom);

            // Translate this svg element to leave some margin.
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left}, ${margin.top})`);

            // Scale and axis
            var xScale = d3.scaleBand()
                .domain(mydata.map(d => d.year))    // This is the min and the max of the data
                .range([0, width])                  // This is the corresponding value I want in Pixel
                .padding(0.1);

            var yScale = d3.scaleLinear()
                .domain(d3.extent(mydata, d => d.value))
                .range([height, 0]);

            var xAxis = d3.axisBottom()
                .scale(xScale)
                .tickFormat(d3.timeFormat("%b %Y"))
                .tickValues(xScale.domain().filter((d, i) => !(i % 1)));

            g.append('g')
                .attr("class", "x-axis")
                .attr('transform', `translate(0, ${height + 5})`)
                .call(xAxis);

            // Bars
            var colors = {handle: "#000", bar: "#009688"};

            g.selectAll('rect')
                .data(mydata)
                .enter()
                .append('rect')
                .attr('class', 'bar')
                .attr('x', d => xScale(d.year))
                .attr('y', d => height - yScale(d.value))
                .attr('width', xScale.bandwidth())
                .attr('height', d => yScale(d.value))
                .attr('fill', colors.bar)
                .attr('opacity', 1);
                
            // Append brush
            var brush = d3.brushX()
                .handleSize(8)
                .extent([[0, 0], [width, height]])
                .on('start brush end', brushing);

            const gBrush = g.append('g')
                .call(brush)
                .call(brush.move, [0, width]);

            // Custom handlers
            const gHandles = gBrush.selectAll('g.handles')
                .data(['handle--o', 'handle--e'])
                .enter()
                .append('g')
                .attr('class', d => `handles ${d}`)
                .attr('fill', colors.handle)
                .attr('transform', d => {
                const x = d == 'handle--o' ? 0 : width;
                return `translate(${x}, 0)`;
                });

            // Label
            var yearFormat = d3.timeFormat("%Y");
            gHandles.selectAll('text')
                .data(d => [d])
                .enter()
                .append('text')
                .attr('text-anchor', 'middle')
                .attr('dy', 10)
                .attr('dx', -10)
                .text(d =>  d == 'handle--o' ? yearFormat(d3.min(xScale.domain())) : yearFormat(d3.max(xScale.domain())));

            // Triangle
            var triangle = d3.symbol()
                .size(50)
                .type(d3.symbolTriangle);

            gHandles.selectAll('.triangle')
                .data(d => [d])
                .enter()
                .append('path')
                .attr('class', d => `triangle ${d}`)
                .attr('d', triangle)
                .attr('transform', d => {
                    const x = d == 'handle--o' ? -6 : 6,
                        rot = d == 'handle--o' ? -90 : 90;
                    return `translate(${x}, ${size.h / 2}) rotate(${rot})`;
                });

            // Visible Line
            gHandles.selectAll('.line')
                .data(d => [d])
                .enter()
                .append('line')
                .attr('class', d => `line ${d}`)
                .attr('x1', 0)
                .attr('y1', 15)
                .attr('x2', 0)
                .attr('y2', size.h - 15)
                .attr('stroke', colors.handle);

            // Functions
            function snappedSelection(bandScale, domain) {
                const min = d3.min(domain),
                    max = d3.max(domain);
                return [bandScale(min), bandScale(max) + bandScale.bandwidth()];
            }

            function filteredDomain(scale, min, max) {
                let dif = scale(d3.min(scale.domain())) - scale.range()[0],
                    iMin = (min - dif) < 0 ? 0 : Math.round((min - dif)/xScale.step()),
                    iMax = Math.round((max - dif)/xScale.step());
                if (iMax == iMin) --iMin; // It happens with empty selections.

                return scale.domain().slice(iMin, iMax);
            }

            function brushing() {
                // based on: https://bl.ocks.org/mbostock/6232537
                if (!d3.event.selection && !d3.event.sourceEvent) return;
                const s0 = d3.event.selection ? d3.event.selection : [1, 2].fill(d3.event.sourceEvent.offsetX),
                        d0 = filteredDomain(xScale, ...s0);
                let s1 = s0;

                if (d3.event.sourceEvent && d3.event.type === 'end') {
                    s1 = snappedSelection(xScale, d0);
                    d3.select(this).transition().call(d3.event.target.move, s1);
                }
                
                // move handlers
                d3.selectAll('g.handles')
                    .attr('transform', d => {
                    const x = d == 'handle--o' ? s1[0] : s1[1];
                    return `translate(${x}, 0)`;
                    });

                // update labels
                d3.selectAll('g.handles').selectAll('text')
                    .attr('dx', d0.length > 1 ? 0 : 6)
                    .text((d, i) => {
                        let year;
                        if (d0.length > 1) {
                            year = d == 'handle--o' ? yearFormat(d3.min(d0)) : yearFormat(d3.max(d0));
                        } else {
                            year = d == 'handle--o' ? yearFormat(d3.min(d0)) : '';
                        } 
                        return year;
                    });

                // update bars
                d3.selectAll('.bar')
                .attr('opacity', d => d0.includes(d.year) ? 1 : 0.2);
            }

            function zoom(svg) {
                const extent = [[margin.left, margin.top], [width - margin.right, height - margin.top]];

                svg.call(d3.zoom()
                    .scaleExtent([1, 32])
                    .translateExtent(extent)
                    .extent(extent)
                    .on("zoom", zoomed));

                function zoomed(event) {
                    xScale.range([margin.left, width - margin.right].map(d => d3.event.transform.applyX(d)));
                    svg.selectAll(".bar").attr("x", d => xScale(d.year)).attr("width", xScale.bandwidth());
                    svg.selectAll(".x-axis").call(xAxis);
                }
            }
        </script>
        -->
    </body>
</html>